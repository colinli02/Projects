{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Colin Li's Projects","text":""},{"location":"#social-media","title":"Social Media","text":"<p>You can find my social links at the bottom-right of the footer, or here:</p>"},{"location":"#site-navigation","title":"Site Navigation","text":"<p>Click the headers (above) to navigate my projects!</p>"},{"location":"GEN_PRO_PROJ/","title":"Software Based Projects","text":""},{"location":"GEN_PRO_PROJ/#ready-evaluate-print-loop-sqlite-based-c-database-2024","title":"Ready Evaluate Print Loop SQlite based C Database (2024)","text":"<p>Repo Link</p> Click to view README.md"},{"location":"GEN_PRO_PROJ/#readevalprint-loop-repl-sqlite-based-database","title":"read\u2013eval\u2013print loop (REPL) sqlite based database","text":""},{"location":"GEN_PRO_PROJ/#description","title":"Description","text":"<p>A simple read\u2013eval\u2013print loop (\"REPL\") c based db.</p> <p>It contains basic sqlite based commands (detailed below), functioning in a command line interface when ran as \"db\\\".</p> <p>It also supports disk persistence, meaning instead of being temporarily stored in the memory (stack), it will be stored into the disk instead.  This means we can access our data when we re-boot, similar to a regular db.</p> <pre><code>[test]\n</code></pre> <p>What is REPL?</p> <p>What is this based on?</p> <p>sqlite For a reference, check out here.</p>"},{"location":"GEN_PRO_PROJ/#commands","title":"Commands","text":"Command name Description Usage .exit Closes command prompt. Must be used to save onto disk .exit insert Inserts entry into db by appending to row insert [row # as integer] [username] [email@emailcom] select ------- .tables -------"},{"location":"GEN_PRO_PROJ/#how-this-works","title":"How this works:","text":"<p>Front End: <pre><code>print_prompt() -&gt; read_input() -&gt; \n</code></pre> This goes on forever until .exit is typed.</p> <p>Back End: <pre><code>print_prompt() -&gt; read_input() -&gt; \n</code></pre></p> <p>[ Main ]  Checks for </p>"},{"location":"GEN_PRO_PROJ/#todo","title":"Todo:","text":"<ul> <li>Move side functions to header file for readability.</li> <li> <p>Keep main in main.c</p> </li> <li> <p>Switch printf to cout&lt;&lt;</p> </li> </ul>"},{"location":"GEN_PRO_PROJ/#side-notes","title":"Side Notes:","text":"<p>This is built for windows. Windows does not support POSIX. Some workarounds were used to replicate getline(), refer to code.</p> <p>Several design considerations: Too long strings.</p> <p>Tips to debug: Figuring out where memory problems? Just simply insert print statement at places where think code is breaking.  Sometimes, no error messages come out because of pointer misuse, so don't know where code goes wrong. Insert print statements in certain places in main to figure out where it breaks.</p> <p>Testing? Consider rspec?</p>"},{"location":"GEN_PRO_PROJ/#pip-quick-access-study-video-extension-2024","title":"PiP Quick Access Study Video Extension (2024)","text":"<p>Repo Link</p> Click to preview <p> </p>"},{"location":"GEN_PRO_PROJ/#dynamic-stat-displayer-2024","title":"Dynamic Stat Displayer (2024)","text":"<ul> <li>Dynamically load stats in cpp</li> </ul>"},{"location":"GEN_PRO_PROJ/#render-deployment-django-cloud-2025","title":"Render Deployment Django Cloud (2025)","text":"<ul> <li>PostgreSQL DB</li> </ul>"},{"location":"ML_PROJ/","title":"ML Projects","text":""},{"location":"ML_PROJ/#building-pytorch-from-source-2025","title":"Building Pytorch from Source (2025)","text":"<p>Built PyTorch from source on Windows 10 using Microsoft Visual Studio 2022 and CMake configuring the build for CUDA 12.4 support and optimizing GPU utilization for deep learning tasks</p>"},{"location":"ML_PROJ/#cuda-tcp-project-2025","title":"CUDA TCP Project (2025)","text":"<p>Repo Link</p> Click to view README.md"},{"location":"ML_PROJ/#cuda-tcp-project-demo-windows","title":"CUDA TCP Project Demo (Windows)","text":"<p>This project demonstrates how to simulate a CUDA-based computational workload over TCP/IP on a Windows platform. The server performs data processing using GPU and handles multiple client requests concurrently, enabling high-performance computations through CUDA.</p>"},{"location":"ML_PROJ/#overview","title":"Overview","text":"<p>This is a single-file project that combines both server and client functionality into one <code>.cpp</code> file, utilizing multithreading to concurrently handle multiple client requests. The server processes the commands sent by the client, performs CUDA-based operations (array addition, matrix multiplication), and sends the results back to the client.</p> <ul> <li>Server: Handles multiple client connections, processes various commands (like array addition and matrix multiplication), and offloads the computational work to the GPU using CUDA.</li> <li>Client: Sends commands to the server (like <code>add</code>, <code>matmul</code>, or <code>exit</code>), receives the results, and displays them. </li> </ul> <p>The server communicates with clients over TCP/IP, and the server is designed to handle multiple requests at the same time by creating a new thread for each client.</p>"},{"location":"ML_PROJ/#key-features","title":"Key Features","text":"<ul> <li>Multithreading: Each client connection is handled in a separate thread, allowing the server to process multiple requests concurrently without blocking.</li> <li>CUDA Acceleration: Array addition and matrix multiplication operations are processed on the GPU using CUDA, leveraging parallel processing capabilities for improved performance.</li> <li>Active Connection Tracking: The server tracks and displays the number of active client connections, ensuring proper management of client sessions.</li> <li>Basic Command Handling: The server supports three commands: <code>add</code> (for array addition), <code>matmul</code> (for matrix multiplication), and <code>exit</code> (to close the connection).</li> <li>Windows-Specific: Uses Windows Socket programming (<code>winsock2</code>) for network communication.</li> </ul>"},{"location":"ML_PROJ/#requirements","title":"Requirements","text":"<p>To build and run this project, ensure you have the following installed:</p> <ul> <li>CUDA Toolkit: Required to compile and run CUDA-based functions. This project uses CUDA 12.6 (latest version at the time).</li> <li>Windows Operating System: This project is designed to run on Windows-based platforms.</li> <li>Visual Studio (or other IDE for CUDA &amp; C++): Visual Studio is commonly used for CUDA development, but any IDE or build environment that supports C++ and CUDA should work.</li> </ul>"},{"location":"ML_PROJ/#dependencies","title":"Dependencies","text":"<ul> <li>CUDA Toolkit: For GPU-accelerated operations such as array addition and matrix multiplication.</li> <li>Winsock2: Windows-specific library for socket communication (built into Windows).</li> </ul>"},{"location":"ML_PROJ/#commands","title":"Commands","text":""},{"location":"ML_PROJ/#command-prefix","title":"Command Prefix:","text":"<ul> <li>None: No prefix is required for the commands.</li> </ul>"},{"location":"ML_PROJ/#command-suffixes","title":"Command Suffixes:","text":"<ul> <li><code>add</code>: Triggers the CUDA-based array addition operation.</li> <li><code>matmul</code>: Triggers the CUDA-based matrix multiplication operation.</li> <li><code>exit</code>: Terminates the client-server connection.</li> </ul>"},{"location":"ML_PROJ/#example-client-interaction","title":"Example Client Interaction:","text":"<p>```sh Enter command (add, matmul, exit): add Response from server: Result: {11, 22, 33, 44, 55}</p> <p>Enter command (add, matmul, exit): matmul Response from server: Result: 30 24 18 84 69 54 138 114 90</p> <p>Enter command (add, matmul, exit): exit Server exiting...</p>"},{"location":"ML_PROJ/#simple-cnn-bp-implementation","title":"Simple CNN &amp; BP Implementation","text":""},{"location":"ML_PROJ/#cuda-based-mnist-transformer","title":"CUDA based MNIST Transformer","text":""},{"location":"ML_PROJ/#mnist-vae","title":"MNIST VAE","text":""},{"location":"ML_PROJ/#conditional-pixelcnn","title":"Conditional PixelCNN","text":""},{"location":"MicroControllerProjects/","title":"Micro-controller Projects","text":""},{"location":"MicroControllerProjects/#robotic-coin-picker-march-2022-april-2022","title":"Robotic Coin Picker (March 2022 - April 2022)","text":"<ul> <li>PIC32 micro-controller controlled and battery powered robot coin picker</li> <li>Powered by C software for robot wheel control, magnetic arm movement, and boundary perimeter detection of AC perimeter</li> <li>Debugged and optimised software and hardware issues</li> </ul> <p>Links</p> <p>Github Code Link</p> <p>Raw Code Link</p> <p>Wheel Code Separate</p> <p>Youtube Link</p> Click to show code Robot_Base.c<pre><code>// Robot_Base.c for PIC32 \n// Pin Assignments (PIC32)\n// RB0 RB1 - Wheels \n// RA2 RA3 - wheels\n// RB2 RB3 - ADC \n// RA3 RB4 - ?? unknown \n// RB5 - getPeriod -&gt; get frequency for coin detector \n// RB13 - ElectroMagnet \n// RB15 - Servo Base, RB14 Servo Arm \n\n\n#include &lt;XC.h&gt;\n#include &lt;sys/attribs.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// Configuration Bits (somehow XC32 takes care of this)\n#pragma config FNOSC = FRCPLL       // Internal Fast RC oscillator (8 MHz) w/ PLL\n#pragma config FPLLIDIV = DIV_2     // Divide FRC before PLL (now 4 MHz)\n#pragma config FPLLMUL = MUL_20     // PLL Multiply (now 80 MHz)\n#pragma config FPLLODIV = DIV_2     // Divide After PLL (now 40 MHz) \n#pragma config FWDTEN = OFF         // Watchdog Timer Disabled\n#pragma config FPBDIV = DIV_1       // PBCLK = SYCLK\n#pragma config FSOSCEN = OFF        // Turn off secondary oscillator on A4 and B4\n\n// Defines\n#define SYSCLK 40000000L\n#define FREQ 100000L // We need the ISR for timer 1 every 10 us#include &lt;XC.h&gt;\n#define Baud2BRG(desired_baud)( (SYSCLK / (16*desired_baud))-1) \n\n//For the coin detector\n#define MINFREQ 90000 //FOR TESTING, not used. Uses dynamic freq init\n#define MAXFREQ 1000000\n\n//for perimeter detector\n#define VOLTRANGEMIN_PERIMETER 0.10\n#define VOLTRANGEMAX_PERIMETER 100\n\n#define MAXCOINS 20\n\n  volatile int ISR_pw = 240, ISR_base = 60,ISR_cnt = 0, ISR_frc;\n\n  // The Interrupt Service Routine for timer 1 is used to generate one or more standard\n  // hobby servo signals.  The servo signal has a fixed period of 20ms and a pulse width\n  // between 0.6ms and 2.4ms.\n\n    // Use the core timer to wait for 1 ms.\n  void wait_1ms(void)\n  {\n      unsigned int ui;\n      _CP0_SET_COUNT(0); // resets the core timer count\n\n      // get the core timer count\n      while ( _CP0_GET_COUNT() &lt; (SYSCLK/(2*1000)) );\n  }\n\n   void waitms(int len)\n  {\n    while(len--) wait_1ms();\n  }\n\n\n  void __ISR(_TIMER_1_VECTOR, IPL5SOFT) Timer1_Handler(void)\n  {\n    IFS0CLR = _IFS0_T1IF_MASK; // Clear timer 1 interrupt flag, bit 4 of IFS0\n\n    //waitms(5);\n    ISR_cnt++;\n\n    int flag = 0;\n    if (ISR_cnt &lt; ISR_pw)\n    {\n      LATBbits.LATB14 = 1;\n    }\n    else\n    {\n      LATBbits.LATB14 = 0;\n    }\n\n    if (ISR_cnt &lt; ISR_base)\n    {\n      LATBbits.LATB15 = 1;\n    }\n    else\n    {\n      LATBbits.LATB15 = 0;\n    }\n\n\n\n    if (ISR_cnt &gt;= 2000)\n    {\n      ISR_cnt = 0; // 2000 * 10us=20ms\n      ISR_frc++;\n    }\n  }\n\n  void SetupTimer1 (void)\n  {\n    // Explanation here: https://www.youtube.com/watch?v=bu6TTZHnMPY\n    __builtin_disable_interrupts();\n    PR1 =(SYSCLK/FREQ)-1; // since SYSCLK/FREQ = PS*(PR1+1)\n    TMR1 = 0;\n    T1CONbits.TCKPS = 0; // 3=1:256 prescale value, 2=1:64 prescale value, 1=1:8 prescale value, 0=1:1 prescale value\n    T1CONbits.TCS = 0; // Clock source\n    T1CONbits.ON = 1;\n    IPC1bits.T1IP = 5;\n    IPC1bits.T1IS = 0;\n    IFS0bits.T1IF = 0;\n    IEC0bits.T1IE = 1;\n\n    INTCONbits.MVEC = 1; //Int multi-vector\n    __builtin_enable_interrupts();\n  }\n\n\n\n\n  #define PIN_PERIOD (PORTB&amp;(1&lt;&lt;5))\n\n  // GetPeriod() seems to work fine for frequencies between 200Hz and 700kHz.\n  long int GetPeriod (int n)\n  {\n    int i;\n    unsigned int saved_TCNT1a, saved_TCNT1b;\n\n      _CP0_SET_COUNT(0); // resets the core timer count\n    while (PIN_PERIOD!=0) // Wait for square wave to be 0\n    {\n      if(_CP0_GET_COUNT() &gt; (SYSCLK/4)) return 0;\n    }\n\n      _CP0_SET_COUNT(0); // resets the core timer count\n    while (PIN_PERIOD==0) // Wait for square wave to be 1\n    {\n      if(_CP0_GET_COUNT() &gt; (SYSCLK/4)) return 0;\n    }\n\n      _CP0_SET_COUNT(0); // resets the core timer count\n    for(i=0; i&lt;n; i++) // Measure the time of 'n' periods\n    {\n      while (PIN_PERIOD!=0) // Wait for square wave to be 0\n      {\n        if(_CP0_GET_COUNT() &gt; (SYSCLK/4)) return 0;\n      }\n      while (PIN_PERIOD==0) // Wait for square wave to be 1\n      {\n        if(_CP0_GET_COUNT() &gt; (SYSCLK/4)) return 0;\n      }\n    }\n\n    return  _CP0_GET_COUNT();\n  }\n\n  void UART2Configure(int baud_rate)\n  {\n      // Peripheral Pin Select\n      U2RXRbits.U2RXR = 4;    //SET RX to RB8\n      RPB9Rbits.RPB9R = 2;    //SET RB9 to TX\n\n      U2MODE = 0;         // disable autobaud, TX and RX enabled only, 8N1, idle=HIGH\n      U2STA = 0x1400;     // enable TX and RX\n      U2BRG = Baud2BRG(baud_rate); // U2BRG = (FPb / (16*baud)) - 1\n\n      U2MODESET = 0x8000;     // enable UART2\n  }\n\n  void uart_puts(char * s)\n  {\n    while(*s)\n    {\n      putchar(*s);\n      s++;\n    }\n  }\n\n  void delay_ms(int msecs)\n  {\n    int ticks;\n    ISR_frc = 0;\n    ticks = msecs / 20;\n    while (ISR_frc &lt; ticks);\n  }\n\n  char HexDigit[]=\"0123456789ABCDEF\";\n  void PrintNumber(long int val, int Base, int digits)\n  { \n    int j;\n    #define NBITS 32\n    char buff[NBITS+1];\n    buff[NBITS]=0;\n\n    j=NBITS-1;\n    while ( (val&gt;0) | (digits&gt;0) )\n    {\n      buff[j--]=HexDigit[val%Base];\n      val/=Base;\n      if(digits!=0) digits--;\n    }\n    uart_puts(&amp;buff[j+1]);\n  }\n\n  // Good information about ADC in PIC32 found here:\n  // http://umassamherstm5.org/tech-tutorials/pic32-tutorials/pic32mx220-tutorials/adc\n  void ADCConf(void)\n  {\n      AD1CON1CLR = 0x8000;    // disable ADC before configuration\n      AD1CON1 = 0x00E0;       // internal counter ends sampling and starts conversion (auto-convert), manual sample\n      AD1CON2 = 0;            // AD1CON2&lt;15:13&gt; set voltage reference to pins AVSS/AVDD\n      AD1CON3 = 0x0f01;       // TAD = 4*TPB, acquisition time = 15*TAD \n      AD1CON1SET=0x8000;      // Enable ADC\n  }\n\n  int ADCRead(char analogPIN)\n  {\n      AD1CHS = analogPIN &lt;&lt; 16;    // AD1CHS&lt;16:19&gt; controls which analog pin goes to the ADC\n\n      AD1CON1bits.SAMP = 1;        // Begin sampling\n      while(AD1CON1bits.SAMP);     // wait until acquisition is done\n      while(!AD1CON1bits.DONE);    // wait until conversion done\n\n      return ADC1BUF0;             // result stored in ADC1BUF0\n  }\n\n  void ConfigurePins(void)\n  {\n    // Configure pins as analog inputs\n        //Modified jesus analog -&gt; output \n        //analog pins must be init as 1 \n            //ANSELBbits.ANSB2 = 1;   // set RB2 (AN4, pin 6 of DIP28) as analog pin\n            //TRISBbits.TRISB2 = 1;   // set RB2 as an input\n            //ANSELBbits.ANSB3 = 1;   // set RB3 (AN5, pin 7 of DIP28) as analog pin\n            //TRISBbits.TRISB3 = 1;   // set RB3 as an input\n            //ANSELBbits.ANSB12 = 1;   \n            //TRISBbits.TRISB12 = 1;\n            TRISBbits.TRISB2 = 1;\n            LATBbits.LATB2 = 1;\n\n            TRISBbits.TRISB3 = 1;\n            LATBbits.LATB3 = 1;\n\n\n    // Configure digital input pin to measure signal period\n        ANSELB &amp;= ~(1&lt;&lt;5); // Set RB5 as a digital I/O (pin 14 of DIP28)\n        TRISB |= (1&lt;&lt;5);   // configure pin RB5 as input\n        CNPUB |= (1&lt;&lt;5);   // Enable pull-up resistor for RB5\n\n    // Configure output pins\n        TRISAbits.TRISA0 = 0; // pin  2 of DIP28\n        TRISAbits.TRISA1 = 0; // pin  3 of DIP28\n        TRISBbits.TRISB0 = 0; // pin  4 of DIP28\n        TRISBbits.TRISB1 = 0; // pin  5 of DIP28\n        TRISAbits.TRISA2 = 0; // pin  9 of DIP28\n        TRISAbits.TRISA3 = 0; // pin 10 of DIP28\n        TRISBbits.TRISB4 = 0; // pin 11 of DIP28\n\n\n    //These pins are added \n        TRISBbits.TRISB6 = 0;\n        LATBbits.LATB6 = 0;\n        TRISBbits.TRISB15 = 0; //14 / 15 servo arm\n        LATBbits.LATB15 = 0;\n        TRISBbits.TRISB14 = 0;\n        LATBbits.LATB14 = 0;\n        TRISBbits.TRISB13 = 0; //EM \n        LATBbits.LATB13 = 0;\n\n        INTCONbits.MVEC = 1;\n  }\n\n//==========================================================\n//\n//                  Added Robot Functions\n//\n//==========================================================\n    //Function for moving straight\n    void moveStraight(void)\n    {           \n        LATBbits.LATB0 = 0;\n        LATBbits.LATB1 = 1;\n        TRISAbits.TRISA2 = 0; \n        TRISAbits.TRISA3 = 1;       \n        }\n\n    void moveLeft(void)\n    {           \n        LATBbits.LATB0 = 0;\n        LATBbits.LATB1 = 0;\n        TRISAbits.TRISA2 = 0; \n        TRISAbits.TRISA3 = 1;       \n    }\n\n    void moveRight(void)\n    {           \n        LATBbits.LATB0 = 0;\n        LATBbits.LATB1 = 1;\n        TRISAbits.TRISA2 = 0; \n        TRISAbits.TRISA3 = 0;       \n    }\n\n    void moveBack()\n    {\n        LATBbits.LATB0 = 1;\n        LATBbits.LATB1 = 0;\n        TRISAbits.TRISA2 = 1; \n        TRISAbits.TRISA3 = 0; \n    }\n\n    void moveStop()\n    {\n        LATBbits.LATB0 = 0;\n        LATBbits.LATB1 = 0;\n        TRISAbits.TRISA2 = 0; \n        TRISAbits.TRISA3 = 0; \n    }\n//==========================================================\n//\n//                          MAIN\n//\n//==========================================================\n// In order to keep this as nimble as possible, avoid\n// using floating point or printf() on any of its forms!\n\n  void main(void)\n  {\n    volatile unsigned long t=0;\n    int adcval4, adcval5;\n    long int v;\n    unsigned long int count, f;\n    unsigned char LED_toggle=0;\n    float T;\n    int i = 0;\n\n    //for servo\n    char buf[32];\n    int pw;\n    int base;\n\n    //for adctest\n    float voltage4, voltage5;\n\n    CFGCON = 0;\n    DDPCON = 0;\n    unsigned long int freqInit;\n\n    UART2Configure(115200);  // Configure UART2 for a baud rate of 115200\n    ConfigurePins();\n    SetupTimer1();\n\n    ADCConf(); // Configure ADC\n\n    waitms(500); // Give PuTTY time to start\n    uart_puts(\"\\x1b[2J\\x1b[1;1H\"); // Clear screen using ANSI escape sequence.\n    uart_puts(\"\\r\\nPIC32 multi I/O example.\\r\\n\");\n    uart_puts(\"Measures the voltage at channels 4 and 5 (pins 6 and 7 of DIP28 package)\\r\\n\");\n    uart_puts(\"Measures period on RB5 (pin 14 of DIP28 package)\\r\\n\");\n    uart_puts(\"Toggles RA0, RA1, RB0, RB1, RA2 (pins 2, 3, 4, 5, 9, of DIP28 package)\\r\\n\");\n    uart_puts(\"Generates Servo PWM signals at RA3, RB4 (pins 10, 11 of DIP28 package)\\r\\n\\r\\n\");\n\n    count=GetPeriod(100);\n\n    int coinCount = 0;\n\n    //Initializes freqInit   \n    if(count &gt; 0)\n    {\n        freqInit = ((SYSCLK/2L)*100L)/count;\n    }\n\n    while(1)\n    {\n        count=GetPeriod(100);\n\n        //Perimeter Detector \n        adcval4 = ADCRead(4); // reads AN4 aka RB12     \n        voltage4=adcval4*3.3/1023.0;\n\n        adcval5 = ADCRead(5);   //reads AN5 aka \n        voltage5=adcval5*3.3/1023.0;\n\n        //If current frequency fluctuates under freqInit, freqInit initializes again \n        if(f &lt; freqInit)\n        {\n            freqInit = ((SYSCLK/2L)*100L)/count;\n        }\n\n\n\n\n        if(coinCount == MAXCOINS) //if has collected and counted max number of coins\n        {\n                //does a lil dance upon win\n                moveBack();\n                waitms(500);\n                moveStop();\n\n                moveStraight();\n                waitms(500);\n                moveStop();\n\n                moveBack();\n                waitms(500);\n                moveStop();\n\n                moveStraight();\n                waitms(500);\n                moveStop();\n\n                moveLeft();\n                waitms(4000);\n\n                moveStop();\n                waitms(8000);\n\n        }\n\n        //Perimeter Detector \n        adcval4 = ADCRead(4); // reads AN4 aka RB12     \n        voltage4=adcval4*3.3/1023.0;\n\n        adcval5 = ADCRead(5);   //reads AN5 aka \n        voltage5=adcval5*3.3/1023.0;\n\n        fflush(stdout);\n\n\n        moveStraight();\n\n        if((voltage4 &gt; VOLTRANGEMIN_PERIMETER &amp;&amp; voltage4 &lt; VOLTRANGEMAX_PERIMETER) || (voltage5 &gt; VOLTRANGEMIN_PERIMETER &amp;&amp; voltage5 &lt; VOLTRANGEMAX_PERIMETER))\n        {\n            //Do not put in a function. Too long runtime (calls a func within a func)\n            moveStop();\n            waitms(200);\n            moveBack();\n            waitms(1000);\n            moveRight();\n            waitms(1000); //45 deg\n            moveStop();\n        }\n\n\n\n        if(count&gt;0)\n        {\n            f=((SYSCLK/2L)*100L)/count;\n            uart_puts(\"f=\");\n            PrintNumber(f, 10, 7);\n            uart_puts(\"Hz, count=\");\n            PrintNumber(count, 10, 6);\n\n            uart_puts(\" freqinit=\");\n            PrintNumber(freqInit, 10, 7);\n            uart_puts(\"          \\r\");\n\n     //Coin detector system (added code)\n     //Note to self: Turning / perimeter detector doesnt work when stuck here \n     //detects if frequency is within a range\n        if (f &gt; freqInit+1000 &amp;&amp; f &lt; MAXFREQ)\n        { \n\n        //moves back to compensate for arm\n            moveStop();\n            moveBack(); \n            waitms(190);\n            moveStop();\n            waitms(200);\n\n          pw = 60;\n          base = 200;\n          if ((pw &gt;= 60) &amp;&amp; (pw &lt;= 240)&amp;&amp;(base&gt;=60) &amp;&amp;(base&lt;=240))\n          {\n            //grab arm drops down\n            waitms(300);\n            ISR_base = base;\n            waitms(300);\n            ISR_pw = pw+5;\n            waitms(300);\n\n            //turn on EM\n            LATBbits.LATB13 = 1;\n            //delay_ms(1000);\n\n            //sweeps base a little while magnet is still on\n                waitms(2000);\n                ISR_base = 150; \n                waitms(2000);\n\n            //return to default \n                //rotates arm\n            while(ISR_pw &lt;= 240){\n              waitms(5);\n              ISR_pw+=1;\n            }\n               // ISR_pw = 240; //rotates arm to beginning \n                //delay_ms(2000);\n                //delay_ms(400);\n\n            //rotates base to ISR_base = 70; //rotates base back to beginning\n                waitms(2000);\n                while(ISR_base &gt;= 70) //deca\n                {\n                waitms(5);\n                ISR_base-=1;\n                }\n\n                waitms(2000);\n\n            //turn off EM\n            LATBbits.LATB13 = 0;\n            waitms(1000);\n\n\n\n            //Reintializing the freqInit upon coin pickup\n            waitms(2000);\n            count=GetPeriod(100);\n            if(count &gt; 0)\n                {\n                  freqInit = ((SYSCLK/2L)*100L)/count;\n                }\n\n            coinCount++;\n\n          }\n          else //if arm angles are out of range\n          {\n            printf(\"%d is out of the valid range\\r\\n\", pw);\n          }\n\n        }\n\n      } //if count bracket\n      else //if cannot detect frequency \n      {\n        uart_puts(\"NO SIGNAL                     \\r\");\n      }\n\n      waitms(200);\n    } //while(1) bracket\n  }\n</code></pre>"},{"location":"MicroControllerProjects/#diode-heartrate-monitor-feb-2022-march-2022","title":"Diode Heartrate Monitor (Feb. 2022 - March 2022)","text":"<p>This first video shows a similar project of a temperature monitor using similar principles, based on the same code but with different hardware setups.</p> <p>The circuit works by using the op-amp to amplify the weak signal emitted from the light passing through the tissue containing blood.  Then this information is processed using the microcontroller circuit and 2 codes to generate a heart rate monitor.</p> <p>Temperature Monitor Demo</p> <p>Heart-rate Monitor Demo</p> Click to show Python code heart-mtr_graphing.py<pre><code>import string\n\n\nimport time\nimport serial\nimport serial.tools.list_ports\n\n\n\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.animation as animation\nimport sys, time, math\n\nxsize=900\n\n# configure the serial port\ntry:\n    ser = serial.Serial(\n        port='COM4', # Change as needed\n        baudrate=115200,\n        parity=serial.PARITY_NONE,\n        stopbits=serial.STOPBITS_TWO,\n        bytesize=serial.EIGHTBITS\n    )\n    ser.isOpen()\nexcept:\n    portlist=list(serial.tools.list_ports.comports())\n    print ('Available serial ports:')\n    for item in portlist:\n       print (item[0])\n    exit()\n\n\ndef data_gen():\n    t = data_gen.t\n    while True:\n       #val = ''\n       t+=1\n\n       val = ser.readline() #reads the port as a byte\n       #print(type(val))#currently is a byte\n\n       #convert byte to float\n       #convert byte into string first\n       val = val.decode('utf-8') \n       #print(type(val)) #currently is a string\n\n       #removes all letters except beginning \n       #removes all letters\n       val = val.replace('V0=', '')\n       val = val.replace('V1=', '')\n       val = val.replace('V2=', '')\n       val = val.replace('V3=', '')\n       val = val.replace('V4=', '')\n       val = val.replace('V5=', '')\n       val = val.replace('V6=', '')\n       val = val.replace('V7=', '')\n       val = val.replace('V', '')\n       val = val.replace('=', '')\n       #removes random left over characters that block float conversion \n       val = val.replace('=', '')\n       val = val.replace(' ', '')\n       val = val.replace(' '' ', '')\n\n       val = val[0:5] #keeps first 4 digits of string\n\n       #then converts string to float\n       #print(type(val)) #currently is a string\n       #print(len(val)) #for debugging\n       val = float(val)\n       val = val/45\n       #val = val*2\n\n       #appends t\n       #time = \"*t\"\n       #listOfStrings = [val,time]\n       #val = \"\".join(listOfStrings)\n\n       #print(type(val))\n       #val=100.0*math.sin(t*2.0*3.1415/100.0) #this is a float\n       print(val)\n       yield t, val\n\ndef run(data):\n    # update the data\n    t,y = data\n    if t&gt;-1:\n        xdata.append(t)\n        ydata.append(y)\n        if t&gt;xsize: # Scroll to the left.\n            ax.set_xlim(t-xsize, t)\n        line.set_data(xdata, ydata)\n\n    return line,\n\ndef on_close_figure(event):\n    sys.exit(0)\n\ndata_gen.t = -1\nfig = plt.figure()\nfig.canvas.mpl_connect('close_event', on_close_figure)\nax = fig.add_subplot(111)\nline, = ax.plot([], [], lw=2)\nax.set_ylim(0, 120)\nax.set_xlim(0, xsize)\nax.grid()\nxdata, ydata = [], []\n\n# Important: Although blit=True makes graphing faster, we need blit=False to prevent\n# spurious lines to appear when resizing the stripchart.\nani = animation.FuncAnimation(fig, run, data_gen, blit=False, interval=50, repeat=False)\nplt.show()\n</code></pre> Click to show C code heart-mtr_at89.c<pre><code>// This code is mostly from http://efundies.com/avr-and-printf/\n\n#define F_CPU 16000000UL\n\n#include &lt;avr/io.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;util/delay.h&gt;\n#include \"usart.h\"\n\nunsigned int ReadChannel(unsigned char mux)\n{\n    ADCSRA = (1&lt;&lt;ADEN) | (1&lt;&lt;ADPS1) | (1&lt;&lt;ADPS0); // frequency prescaler\n    ADMUX = mux; // channel select\n    ADMUX |= (1&lt;&lt;REFS1) | (1&lt;&lt;REFS0); \n    ADCSRA |= (1&lt;&lt;ADSC); // Start conversion\n    while ( ADCSRA &amp; (1&lt;&lt;ADSC) ) ;\n    ADCSRA |= (1&lt;&lt;ADSC); // a transformation \u201csingle conversion\u201d\n    while ( ADCSRA &amp; (1&lt;&lt;ADSC) );\n    ADCSRA &amp;= ~(1&lt;&lt;ADEN); // Disable ADC\n    return ADCW;\n}\n\nint main( void )\n{\n    unsigned int adc;\n\n    usart_init (); // configure the usart and baudrate\n    DDRB |= 0x01;\n    PORTB |= 0x01;\n\n    printf(\"\\nADC test\\n\");\n\n    while(1)\n    {\n        adc=ReadChannel(0);\n        //printf(\"ADC[0]=0x%03x, %fV\\n\", adc, (adc*5.0)/1023.0);\n        printf(\"%f\\n\",(adc*5.0)/1023.0);\n        PORTB ^= 0x01;\n        _delay_ms(500);\n    }\n}\n</code></pre> <ul> <li>Developed AT89LP51RC2 micro-controller based photoelectric heart rate monitor</li> <li>Wrote software that would read micro-controller using PuTTY and C</li> <li>Further graphed data with Python using MatLab functions to graph heart rate</li> </ul>"},{"location":"MicroControllerProjects/#ac-voltmeter-march-2022","title":"AC Voltmeter (March 2022)","text":"<p>Youtube Demo</p> Click to show code adc_voltmeter.c<pre><code>//March 2022\n\n#include &lt;stdio.h&gt;\n#include &lt;at89lp51rd2.h&gt;\n\n// ~C51~ \n\n#define CLK 22118400L\n#define BAUD 115200L\n#define ONE_USEC (CLK/1000000L) // Timer reload for one microsecond delay\n#define BRG_VAL (0x100-(CLK/(16L*BAUD)))\n\n#define ADC_CE  P2_0\n#define BB_MOSI P2_1\n#define BB_MISO P2_2\n#define BB_SCLK P2_3\n\n\n\n//LCD Headers\n#define CLK    22118400L // SYSCLK frequency in Hz\n#define BAUD     115200L // Baud rate of UART in bps\n#define ONE_USEC (CLK/1000000L) // Timer reload for one microsecond delay\n\n#if (CLK/(16L*BAUD))&gt;0x100\n#error Can not set baudrate\n#endif\n#define BRG_VAL (0x100-(CLK/(16L*BAUD)))\n\n//LCD Pins\n#define LCD_RS P3_2\n//#define LCD_RW PX_X // Not used in this code.  Connect pin to GND\n#define LCD_E  P3_3\n#define LCD_D4 P3_4\n#define LCD_D5 P3_5\n#define LCD_D6 P3_6\n#define LCD_D7 P3_7\n#define CHARS_PER_LINE 16\n\n//======================================\n//\n//              Headers\n//\n//======================================\nvoid LCD_pulse (void);\nvoid LCD_byte (unsigned char x);\nvoid WriteData (unsigned char x);\nvoid WriteCommand (unsigned char x);\nvoid LCD_4BIT (void);\nvoid LCDprint(char * string, unsigned char line, bit clear);\n\nfloat getHalfPeriod(void);\nfloat PhaseDiffer(void);\n\n\n//======================================\n//\n//             Timer Functions\n//\n//======================================\nunsigned char SPIWrite(unsigned char out_byte)\n{\n    // In the 8051 architecture both ACC and B are bit addressable!\n    ACC=out_byte;\n\n    BB_MOSI=ACC_7; BB_SCLK=1; B_7=BB_MISO; BB_SCLK=0;\n    BB_MOSI=ACC_6; BB_SCLK=1; B_6=BB_MISO; BB_SCLK=0;\n    BB_MOSI=ACC_5; BB_SCLK=1; B_5=BB_MISO; BB_SCLK=0;\n    BB_MOSI=ACC_4; BB_SCLK=1; B_4=BB_MISO; BB_SCLK=0;\n    BB_MOSI=ACC_3; BB_SCLK=1; B_3=BB_MISO; BB_SCLK=0;\n    BB_MOSI=ACC_2; BB_SCLK=1; B_2=BB_MISO; BB_SCLK=0;\n    BB_MOSI=ACC_1; BB_SCLK=1; B_1=BB_MISO; BB_SCLK=0;\n    BB_MOSI=ACC_0; BB_SCLK=1; B_0=BB_MISO; BB_SCLK=0;\n\n    return B;\n}\n\nunsigned char _c51_external_startup(void)\n{\n    AUXR=0B_0001_0001; // 1152 bytes of internal XDATA, P4.4 is a general purpose I/O\n\n    P0M0=0x00; P0M1=0x00;    \n    P1M0=0x00; P1M1=0x00;    \n    P2M0=0x00; P2M1=0x00;    \n    P3M0=0x00; P3M1=0x00;\n\n    // Initialize the pins used for SPI\n    ADC_CE=0;  // Disable SPI access to MCP3008\n    BB_SCLK=0; // Resting state of SPI clock is '0'\n    BB_MISO=1; // Write '1' to MISO before using as input\n\n    // Configure the serial port and baud rate\n    PCON|=0x80;\n    SCON = 0x52;\n    BDRCON=0;\n    #if (CLK/(16L*BAUD))&gt;0x100\n    #error Can not set baudrate\n    #endif\n    BRL=BRG_VAL;\n    BDRCON=BRR|TBCK|RBCK|SPD;\n\n    CLKREG=0x00; // TPS=0000B\n\n    return 0;\n}\n\nvoid wait_us (unsigned char x)\n{\n    unsigned int j;\n\n    TR0=0; // Stop timer 0\n    TMOD&amp;=0xf0; // Clear the configuration bits for timer 0\n    TMOD|=0x01; // Mode 1: 16-bit timer\n\n    if(x&gt;5) x-=5; // Subtract the overhead\n    else x=1;\n\n    j=-ONE_USEC*x;\n    TF0=0;\n    TH0=j/0x100;\n    TL0=j%0x100;\n    TR0=1; // Start timer 0\n    while(TF0==0); //Wait for overflow\n}\n\nvoid waitms (unsigned int ms)\n{\n    unsigned int j;\n    unsigned char k;\n    for(j=0; j&lt;ms; j++)\n        for (k=0; k&lt;4; k++) wait_us(250);\n}\n\n/*Read 10 bits from the MCP3008 ADC converter*/\nunsigned int volatile GetADC(unsigned char channel)\n{\n    unsigned int adc;\n    unsigned char spid;\n\n    ADC_CE=0; // Activate the MCP3008 ADC.\n\n    SPIWrite(0x01);// Send the start bit.\n    spid=SPIWrite((channel*0x10)|0x80); //Send single/diff* bit, D2, D1, and D0 bits.\n    adc=((spid &amp; 0x03)*0x100);// spid has the two most significant bits of the result.\n    spid=SPIWrite(0x00);// It doesn't matter what we send now.\n    adc+=spid;// spid contains the low part of the result. \n\n    ADC_CE=1; // Deactivate the MCP3008 ADC.\n\n    return adc;\n}\n\n//Gets half period of P1_0\nfloat getHalfPeriod() \n{\n  float Period = 0;\n  float myof;\n\n  TR0=0;\n  TMOD&amp;=0B_1111_0000;\n  TMOD |=0B_0000_0001;\n  TH0=0;\n  TL0=0;\n  myof=0;\n  TF0=0;\n  while(P1_0==1);\n  while(P1_0==0);\n  TR0=1;\n  while(P1_0==1)// while(GetADC(P2_4)==1)\n  {  \n    if(TF0) {TF0=0; myof++;}\n  }\n  TR0=0;\n\n  Period=(myof*65536.0+TH0*256.0+TL0)*2.0;\n\n  //Period = Period* 0.59665871121; //debug scaling 838-&gt;500\n\n  return Period;\n}\n\n//Gets Half period if pin 1_1\nfloat getHalfPeriodOther() \n{\n  float Period = 0;\n  float myof;\n\n  TR0=0;\n  TMOD&amp;=0B_1111_0000;\n  TMOD |=0B_0000_0001;\n  TH0=0;\n  TL0=0;\n  myof=0;\n  TF0=0;\n  while(P1_1==1);\n  while(P1_1==0);\n  TR0=1;\n  while(P1_1==1)// while(GetADC(P2_4)==1)\n  {  \n    if(TF0) {TF0=0; myof++;}\n  }\n  TR0=0;\n\n  Period=(myof*65536.0+TH0*256.0+TL0)*2.0;\n\n  //Period = Period* 0.59665871121; //debug scaling 838-&gt;500\n\n  return Period;\n}\n//Gets phase difference \nfloat PhaseDiffer()\n{\n    float myof;\n    float PhaseDiff = 0;\n\n    TR0=0;\n    TMOD&amp;=0B_1111_0000;\n    TMOD |=0B_0000_0001;\n    TH0=0;\n    TL0=0;\n    myof=0;\n    TF0=0;\n\n    while (P1_0==1);\n    while (P1_0==0);\n\n    if (P1_0==0) \n    {\n        TR0 = 1;\n        while (P1_0==0) \n        {\n            if (TF0) \n            {\n                TF0 = 0;\n                myof++;\n            }\n        }\n        TR0 = 0;\n        return PhaseDiff =(myof*65536.0+TH0*256.0+TL0)*0.00005085596*2.0;\n    } \n    else \n    {\n        TR0 = 1;\n        while (P1_0==1) \n        {\n            if (TF0) \n            {\n                TF0 = 0;\n                myof++;\n            }\n        }\n        while (P1_0==0) \n        {\n            if (TF0) \n            {\n                TF0 = 0;\n                myof++;\n            }\n        }\n        TR0 = 0;\n        return PhaseDiff=(myof*65536.0+TH0*256.0+TL0)*0.00005085596*2.0;\n    }\n\n\n}\n\n//======================================\n//\n//              LCD Code\n//\n//======================================\n\nvoid LCD_pulse (void)\n{\n    LCD_E=1;\n    wait_us(40);\n    LCD_E=0;\n}\n\nvoid LCD_byte (unsigned char x)\n{\n    // The accumulator in the 8051 is bit addressable!\n    ACC=x; //Send high nible\n    LCD_D7=ACC_7;\n    LCD_D6=ACC_6;\n    LCD_D5=ACC_5;\n    LCD_D4=ACC_4;\n    LCD_pulse();\n    wait_us(40);\n    ACC=x; //Send low nible\n    LCD_D7=ACC_3;\n    LCD_D6=ACC_2;\n    LCD_D5=ACC_1;\n    LCD_D4=ACC_0;\n    LCD_pulse();\n}\n\nvoid WriteData (unsigned char x)\n{\n    LCD_RS=1;\n    LCD_byte(x);\n    waitms(2);\n}\n\nvoid WriteCommand (unsigned char x)\n{\n    LCD_RS=0;\n    LCD_byte(x);\n    waitms(5);\n}\n\nvoid LCD_4BIT (void) //initializes lcd \n{\n    LCD_E=0; // Resting state of LCD's enable is zero\n    //LCD_RW=0; // We are only writing to the LCD in this program.  Connect pin to GND.\n    waitms(20);\n    // First make sure the LCD is in 8-bit mode and then change to 4-bit mode\n    WriteCommand(0x33);\n    WriteCommand(0x33);\n    WriteCommand(0x32); // Change to 4-bit mode\n\n    // Configure the LCD\n    WriteCommand(0x28);\n    WriteCommand(0x0c);\n    WriteCommand(0x01); // Clear screen command (takes some time)\n    waitms(20); // Wait for clear screen command to finsih.\n}\n\nvoid LCD_print(char * string, unsigned char line, bit clear)\n{\n    int j;\n\n    WriteCommand(line==2?0xc0:0x80);\n    waitms(5);\n    for(j=0; string[j]!=0; j++) WriteData(string[j]);// Write the message\n    if(clear) for(; j&lt;CHARS_PER_LINE; j++) WriteData(' '); // Clear the rest of the line\n}\n\n\n\n\n//======================================\n//\n//              Main\n//\n//======================================\n#define VREF 4.096\n\n//Button Pins\n#define BUTTON1 P2_6\n#define BUTTON2 P2_7\n#define BUTTON3 P2_4\n\nvoid main (void)\n{\n    char strBuffer[30]; //strbuffer empty for purposes of LCD displaying\n    float HalfPeriod;\n    float HalfPeriod2;\n\n    int V516 = 0; //test if output is 420 is wrong\n    int V200 = 0;\n    int V1 = 0;\n    int V2 = 0;\n    float PhaseDiff = 0;\n\n    //unsigned char i;\n    //float halfPeriod; \n\n    waitms(500);    \n    printf(\"\\n\\nAT89LP51Rx2 SPI ADC test program.\\n\");\n\n    LCD_4BIT(); //lcd initialization \n\n\n//always running\nwhile(1)\n{\n//=========================================================\n// Putty terminal display (ctrl + T in cross IDE For putty\n//=========================================================\n\n//Gets Half Period  \n    HalfPeriod = getHalfPeriod();\n    HalfPeriod2 = getHalfPeriodOther();\n    HalfPeriod = HalfPeriod * 2.24945563/1000/1000/100; //converts to 0.01, 2.24945563E-8 multiplier\n    HalfPeriod2 = HalfPeriod2 * 2.24945563/1000/1000/100; //converts to 0.01, 2.24945563E-8 multiplier\n    printf(\"\\n Half Period 1 = %10.5f\", HalfPeriod);\n    printf(\"\\n Half Period 2 = %10.5f\", HalfPeriod2);\n\n\n//Volt RMS\n    while (P1_0 == 1);\n    while (P1_0 == 0 );\n    waitms(HalfPeriod * 1000); // 0.01/444552.0 //waits the halfperiod  \n    V516 = GetADC(0); //Will have to double check the math\n    V516 = V516*0.03968253968/4.6; //5/126   factoring in Vdd\n    printf(\"\\n Voltage 1 = %i\", V516);\n\n    while (P1_1 == 1);\n    while (P1_1 == 0 );\n    waitms(HalfPeriod2 * 1000);\n    V200 = GetADC(1);\n    V200 = V200*0.03968253968/4.6;\n    printf(\"\\n Voltage 2 = %i\", V200);\n\n        //for(i=0; i&lt;8; i++)\n        //{\n        //y=(GetADC(i)*VREF)/1023.0; // Convert the 10-bit integer from the ADC to voltage\n        //printf(\"V%d=%5.3f \", i, y);\n        //}\n\n\n//Phase Difference\nPhaseDiff = PhaseDiffer();\nprintf(\"\\n PhaseDiff = %f\", PhaseDiff);\n\nprintf(\"\\r\"); // Carriage return only.\n//=========================================================\n// :LCD Display on Board\n//=========================================================\n    //Display, using an LCD, the magnitude of both inputs in volts RMS, and the phase\n    //difference between the reference and test signals in degrees, taking care of displaying the\n    //correct sign. Optionally, you can also display the frequency of the reference signal in Hz. \n\n//prints to LCD Screen\n\n    //Prints \"Press Button To Start\" upon start \n    //if(BUTTON1 || BUTTON2 ||BUTTON3 == 0)\n    //{\n        //LCD_print(\"Press Button\", 1, 1);  \n        //LCD_print(\"To Start\", 2, 1);\n\n    //}\n    //upon button press, prints period (half period * 2)\n        if(BUTTON1==0)\n        {\n        LCD_print(\"HALF PERIOD.:\", 1, 1);\n        sprintf(strBuffer, \"%.5f %.5f\", HalfPeriod, HalfPeriod2);   //prints frequency (var y)\n        LCD_print(strBuffer, 2, 1);\n        }\n    //prints inputs in volts RMS\n        else if(BUTTON2==0)\n        {\n        LCD_print(\"VOLT RMS. :\", 1, 1);\n        //Will only update when number is non-zero\n        if(V516 &gt; 0)\n        V1 = V516;\n        if(V200 &gt; 0)\n        V2 = V200;\n        sprintf(strBuffer, \"%i, %i\", V1, V2); \n        LCD_print(strBuffer, 2, 1);\n        }\n    //prints phase differnce between refernce and test signals in degrees\n        else if(BUTTON3==0)\n        {\n        LCD_print(\"Phase Diff.:\", 1, 1);\n        sprintf(strBuffer, \"%f\", PhaseDiff); \n        LCD_print(strBuffer, 2, 1);\n        }\n\n\n\n    } //end while(1)\n} //end main\n</code></pre> <ul> <li>Built a software based AC voltmeter using C</li> <li>Understood AC circuit concepts to create voltmeter that determined magnitude, phase shift, and phase of AC signals produced by function generator</li> </ul>"}]}